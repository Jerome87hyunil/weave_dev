# 오답노트 - Weave 프로젝트

## 기술 스택

### Frontend
- **Next.js 15.4.7** - React 기반 풀스택 프레임워크 (App Router)
- **React 19.1.0** - UI 라이브러리
- **TypeScript 5** - 정적 타입 검사
- **Tailwind CSS 4** - 유틸리티 기반 CSS 프레임워크

### AI/ML
- **OpenAI API (v5.12.2)** - GPT 모델 연동
- **Google Generative AI (v0.24.1)** - Gemini 모델 연동

### Development Tools
- **Turbopack** - Next.js 개발 서버 (빠른 빌드)
- **ESLint** - 코드 품질 관리

### 배포 환경
- **Vercel** - Next.js 최적화 배포 플랫폼 (예정)

---

## 1. Event handlers cannot be passed to Client Component props

### 오류 상황
- Server Component에서 Client Component로 함수(이벤트 핸들러)를 props로 전달 시도
- Next.js App Router에서는 서버 컴포넌트가 기본값

### 해결 방법
- 이벤트 핸들러를 사용하는 컴포넌트에 'use client' 지시어 추가
- 또는 이벤트 핸들러를 클라이언트 컴포넌트 내부로 이동

### 적용 코드
```tsx
'use client'; // 파일 최상단에 추가

export default function Page() {
  // 이벤트 핸들러 사용 가능
}
```

## 2. API Route 500 Internal Server Error

### 오류 상황
- API 라우트에서 import 문을 파일 최상단에 사용 시 초기화 오류 발생
- Next.js의 API 라우트 컴파일 과정에서 모듈 로딩 이슈

### 해결 방법
- 동적 import 사용하여 런타임에 모듈 로드
- try-catch로 에러 핸들링 강화
- 에러 메시지를 클라이언트에 전달하여 디버깅 용이

### 적용 코드
```typescript
// 기존 (문제 발생)
import OpenAI from 'openai';
const openai = new OpenAI({...});

// 수정 (해결)
const { default: OpenAI } = await import('openai');
const openai = new OpenAI({...});
```

## 3. Invalid MIME type 오류 (OpenAI Vision API)

### 오류 상황
- OpenAI Vision API에서 "400 Invalid MIME type. Only image types are supported" 오류
- OpenAI의 Vision API는 이미지만 지원, PDF나 다른 형식 미지원

### 해결 방법
- Gemini 2.5 Flash Lite 모델로 변경 (멀티모달 지원)
- 이미지, PDF, 오디오, 비디오 모두 처리 가능
- 더 저렴한 비용으로 다양한 파일 형식 처리

### 적용 코드
```typescript
// Gemini 2.5 Flash Lite - 데이터 추출 (멀티모달)
const model = genAI.getGenerativeModel({ 
  model: 'gemini-2.5-flash-lite'
});

// Gemini 2.5 Pro - 문서 생성 (고품질)
const model = genAI.getGenerativeModel({ 
  model: 'gemini-2.5-pro' 
});
```

## 4. document.createElement is not a function 오류

### 오류 상황
- 클라이언트 컴포넌트에서 document 객체 사용 시 오류 발생
- 'use client' 지시어가 있어도 일부 상황에서 서버 사이드 렌더링 중 실행될 수 있음
- Next.js의 hydration 과정에서 발생 가능

### 해결 방법
- window와 document 객체 사용 전 브라우저 환경 체크
- 전역 객체 앞에 window. 명시적 사용
- appendChild/removeChild로 DOM 조작 시 안전하게 처리

### 적용 코드
```typescript
// 문제 발생 코드
const link = document.createElement('a');
link.click();
URL.revokeObjectURL(url);

// 해결 코드
if (typeof window === 'undefined' || typeof document === 'undefined') {
  console.error('브라우저 환경이 아닙니다.');
  return;
}

const link = window.document.createElement('a');
window.document.body.appendChild(link);
link.click();
window.document.body.removeChild(link);
window.URL.revokeObjectURL(url);
```

## 5. 계약서 템플릿 약식/상세 구분 미표시

### 문제 상황
- 소프트웨어 용역 계약서가 상세 버전인데 (상세) 표기가 없었음
- 대부분의 계약서가 상세 버전만 있고 약식 버전이 없었음
- 계약서가 많아져 원하는 계약서 찾기 어려움

### 해결 방법
1. 소프트웨어 계약서 템플릿 생성 (상세/약식 모두)
2. 계약서 카테고리 시스템 구현 (contract-categories.ts)
3. 시각적 계약서 선택 UI 컴포넌트 생성 (ContractTemplateSelector.tsx)
   - 카테고리별 그리드 뷰 (이모지 아이콘 활용)
   - 인기 템플릿 섹션
   - 검색 기능
   - 약식/상세 명확한 표시

### 적용 내용
```typescript
// 계약서 카테고리 정의
{
  id: 'development',
  name: '개발 계약서',
  icon: '💻',
  color: 'bg-blue-100',
  contracts: [
    { id: 'software-contract-detailed', type: 'detailed' },
    { id: 'software-contract-simple', type: 'simple' }
  ]
}
```

## 6. 템플릿 선택 UI 개선 - 모달 적용

### 문제 상황
- 문서 생성 페이지에서 템플릿 선택이 단순 드롭다운으로 되어 있어 불편
- 견적서 템플릿이 다양하지 않아 업종별 맞춤형 견적서 필요
- 계약서와 견적서 템플릿 선택 시 시각적 UI가 없음

### 해결 방법
1. 재사용 가능한 Modal 컴포넌트 생성
2. 견적서 카테고리 시스템 구현 (8개 업종별 카테고리)
   - IT/개발, 디자인/창작, 마케팅/광고, 컨설팅/교육 등
3. DocumentGenerator에 모달 통합
   - 문서 종류 선택 시 자동으로 템플릿 선택 모달 표시
   - 견적서/계약서 각각 전용 선택 UI 제공

### 적용 내용
```typescript
// 모달을 통한 템플릿 선택
const handleDocumentTypeChange = (type: DocumentType) => {
  setDocumentType(type);
  if (type === 'contract' || type === 'quote') {
    setShowTemplateModal(true);  // 자동으로 모달 표시
  }
};
```

## 7. html2canvas lab() 색상 함수 파싱 오류

### 오류 상황
- PDF 내보내기 시 "Attempting to parse an unsupported color function 'lab'" 오류 발생
- Tailwind CSS v4에서 사용하는 lab(), lch(), oklch() 색상 함수를 html2canvas가 지원하지 못함
- html2canvas는 구버전 CSS 색상 형식만 지원

### 해결 방법
1. PDF 생성 전 모든 lab() 색상을 hex 색상으로 변환
2. computed style에서 lab() 함수 감지 시 인라인 스타일로 대체
3. Tailwind 클래스명을 기반으로 적절한 hex 색상 매핑
4. gradient에서 lab() 사용 시 단색으로 대체

### 적용 코드
```typescript
// lab() 색상을 hex로 변환하는 함수
const convertLabColors = (el: HTMLElement) => {
  const processElement = (htmlElem: HTMLElement) => {
    const computedStyle = window.getComputedStyle(htmlElem);
    const properties = ['backgroundColor', 'color', 'borderColor', ...];
    
    properties.forEach(prop => {
      const value = computedStyle.getPropertyValue(prop);
      if (value && value.includes('lab')) {
        // Tailwind 클래스 기반으로 적절한 hex 색상 매핑
        const className = htmlElem.className;
        let newColor = '#000000';
        
        if (className.includes('blue-500')) newColor = '#3b82f6';
        // ... 추가 매핑
        
        htmlElem.style.setProperty(prop, newColor, 'important');
      }
    });
  };
};
```

## 8. 파일 업로드 제한 및 서류 종류 다양화

### 문제 상황
- 데이터 추출 탭에서 오디오/비디오 파일도 업로드 가능했음
- 영수증 단일 형태만 고려되어 있어 세금계산서, 현금영수증 등 다양한 서류 처리 불가
- 추출된 데이터 표시가 단순해서 정보 파악이 어려웠음

### 해결 방법
1. 파일 업로드 시 오디오/비디오 파일 차단 로직 추가
2. 서류 종류 선택 드롭다운 추가 (자동 감지 포함 7가지)
   - 자동 감지, 영수증, 세금계산서, 현금영수증, 인보이스/청구서, 수기 계산서, 기타
3. ExtractedData 타입 확장 (사업자번호, 공급가액, 승인번호 등)
4. API 프롬프트 개선으로 서류별 특화 추출
5. 추출 데이터 UI 개선 (그리드 레이아웃, 서류 종류 뱃지)

### 적용 코드
```typescript
// 파일 타입 체크
if (file.type.startsWith('audio/') || file.type.startsWith('video/')) {
  setError('오디오 및 비디오 파일은 지원하지 않습니다.');
  return;
}

// 서류 종류별 처리
const documentTypePrompt = documentType === 'auto' 
  ? '문서 종류를 자동으로 판별하여'
  : `이 문서는 ${DOCUMENT_TYPES[documentType]}입니다.`;
```

## 9. Vercel 배포 시 html-docx-js 타입 에러

### 오류 상황
- Vercel 빌드 중 `createObjectURL` 함수에서 타입 에러 발생
- `asBlob` 함수가 `Blob | Buffer` 반환하는데 `createObjectURL`은 `Blob | MediaSource`만 허용
- 로컬에서는 문제없지만 프로덕션 빌드에서만 발생

### 해결 방법
- Buffer 타입 체크 후 Blob으로 변환하는 타입 가드 추가
- instanceof 연산자로 런타임 타입 체크
- Buffer인 경우 new Blob()으로 명시적 변환

### 적용 코드
```typescript
// Buffer인 경우 Blob으로 변환
let blob: Blob;
if (docxBlob instanceof Blob) {
  blob = docxBlob;
} else {
  // Buffer를 Blob으로 변환
  blob = new Blob([docxBlob], { 
    type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' 
  });
}
const url = window.URL.createObjectURL(blob);
```